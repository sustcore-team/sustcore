# 等待线程计数器的正确性

当我们假设某一类线程都是善意线程时, 这些线程应当会及时释放掉它们占用的资源。这一点有助于我们提高调度的效率。一个事实是，
如果一个占用着较多资源的线程能够拥有更多的调度机会, 那么它就能够更快地完成它的任务, 从而释放掉它占用的资源。
辨认一个线程是善意线程的方式有很多种。最简单的方法是让用户指定。对于我们微内核的设计而言，我们总是假设提供系统调用的服务线程是善意的。
实际上，我们不得不假设这些服务线程是善意的，一个恶意的服务线程是难以防范的。因此，服务线程总是善意线程是一个合理的假设。
在此基础上，为占用着较多资源的服务线程提供更多的调度机会是一个合理的做法。然而，有些资源可能是由服务线程本身维护的，
这意味着系统无法准确地知道一个服务线程占用了多少资源。同时，一个占有着很多资源的服务线程，其资源并不一定总是会被其它服务线程所等待。
一个更好的测量方式是通过观察一个线程被多少个线程所等待。我们可以通过维护一个等待计数器来实现这一点

## 维护等待计数器

对于每个线程, 我们在其TCB中维护一个等待计数器(变量waiter).
我们将该变量初始化为1.

并在等待与唤醒时采取以下两个操作

1. 当线程A等待线程B时, 我们对线程B的等待计数器做以下操作
    - $B.\text{update}(A.\text{waiter})$

其中$B.\text{update}(x)$的定义如下

```cpp
void update(size_t x) {
    this->waiter += x;
    if (this->wait_tcb != nullptr) {
        this->wait_tcb->update(x);
    }
}
```

即沿着等待链向上更新等待计数器。这样, 线程B的等待计数器就会增加$A.\text{waiter}$的值, 同时B的等待链上的所有线程的等待计数器也会增加$A.\text{waiter}$的值。
该操作的时间复杂度为 $O(d)$ , 其中 $d$ 是等待链的深度。

2. 当线程A被唤醒时, 我们对线程B的等待计数器做以下操作
    - $B.\text{reduce}(A.\text{waiter})$

其中$B.\text{reduce}(x)$的定义如下

```cpp
void reduce(size_t x) {
    this->waiter -= x;
}
```

这是因为, A被唤醒当且仅当B是被唤醒的, 则B不会再等待其它线程了, 因此B的等待计数器应该减少$A.\text{waiter}$的值, 而不需要继续向上更新等待链上的线程的等待计数器。
该操作的时间复杂度为 $O(1)$。

## 如何使用等待计数器

### RR调度算法

当采用RR调度算法时, 分配时间片时, 若为一个不被任何进程等待的进程分配N个时间片, 那么, 对于任何一个进程A, 其应当被分配 $N \times A.\text{waiter}$ 个时间片。
原因如下:

当实际上并没有进程之间的等待关系时, 那么每个进程都应当被分配N个时间片。
当发生等待时, 可以理解为程序的控制权由被等待的进程转移到了等待的进程上。
因此, 被等待的进程的时间片实际上是被等待的进程使用了。
因此, 对于一个被$A.\text{waiter}$个进程所等待的进程B, 它实际上应当被分配 $N \times A.\text{waiter}$ 个时间片。

### CFS公平调度算法

当采用CFS公平调度算法时, 如果一个进程A的运行时间为$A.\text{runtime}$, 则令$A.\text{vruntime} = \frac{A.\text{runtime}}{A.\text{waiter}}$作为排序的依据。
原因如下:

当实际上并没有进程之间的等待关系时, 那么每个进程的`vruntime`都等于它的`runtime`,
此时, 每个进程应该分到 $\frac{1}{N}$ 的运行时间, 其中$N$是进程的总数。
当发生等待时, 可以理解为程序的控制权由被等待的进程转移到了等待的进程上。
因此, 被等待的进程的运行时间实际上是被等待的进程使用了。
因此, 对于一个被 $A.\text{waiter}$ 个进程所等待的进程A, 它实际上应当拥有 $\frac{A.\text{waiter}}{\text{N}}$ 的运行时间, 因为此时, 进程A应该视作等待它的 $A.\text{waiter}$ 个进程的集合体.

## 缺陷

当进行$update(x)$操作时, 操作的时间复杂度为 $O(d)$ , 其中 $d$ 是等待链的深度。
当等待链的深度较大时, 该操作的效率较低。

然而, 微内核中服务进程之间的等待关系通常较为简单, 因此等待链的深度通常较小, 因此该操作的效率通常较高, 可以将其视作一个常数时间操作。