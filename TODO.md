# cap_degrade() 函数(SOLVED)

提供一个Capability降级函数, cap_degrade(), 让进程主动降级自己的Capbility权限, 使得以下操作可以实现:

1. fork() 一个新进程
2. 通过 cap_degrade() 主动降级自身的Capability
3. 通过 exec() 执行新程序, 使得新程序拥有受限的Capability

# printf系列函数的改进

现有的 printf 函数采取的处理流程如下:

1. 在栈中预留一个固定大小的缓冲区, 用于存放格式化后的字符串
2. 通过 _llprintf 函数将格式化后的字符串写入该缓冲区
3. 通过指定的输出函数将缓冲区中的字符串输出

该实现存在的问题为, 当格式化的字符串过长时, 会导致缓冲区溢出.
应当对该实现进行改进, 使得在缓冲区用尽时, 及时输出当前缓冲区内容, 并继续格式化剩余内容.

# Logger 系统改进

将内核不同部分(内存, 进程, 系统调用...)的日志输出进行分类. 具体而言, 通过一个结构体
来存放不同部分的日志输出信息(日志名, 输出函数, 启用情况等), 并提供接口函数用于注册和使用这些日志输出信息.
同时应该避免函数指针的使用.

# ID分配器的改进

利用宏实现一个通用的ID分配器, 允许不同类型的ID使用同一套分配和回收逻辑.
从而简化TID, PID, CAPID等ID的分配器实现.

# SV48 页表的实现

参照已有的 SV39 页表实现, 实现 SV48 页表的相关功能, 包括页表项的定义, 地址转换等.

# 进程调度算法的优化

将进程调度队列分为以下三级

1. 实时队列: 用于存放实时进程, 采用先到先服务(FCFS)调度算法.
2. 普通队列: 用于存放普通进程, 采用时间片轮转(RR)调度算法.
3. 批处理队列: 用于存放批处理进程, 采用多级反馈队列(MFQ)调度算法.
4. 空闲队列: 用于存放空闲进程, 仅在系统无其他可运行进程时调度.

调度器总是优先调度实时队列, 其次是普通队列, 然后是批处理队列, 最后是空闲队列.
普通队列中, 进程时间片的数量由如下方式确定:

1. 首先, 系统分配给 init 进程一定的时间片数量.
2. 若进程 A 拥有 $N$ 个总时间片, 优先级为 $P$, 其子进程为 $B_1, B_2, \cdots , B_M$, 优先级为 $P_1, P_2, \cdots, P_M$,
   则总优先级为 $P_{\text{total}} = P + \sum_{i=1}^{M} P_i$, 则进程 A 的时间片数量为 $N \times \frac{P}{P_{\text{total}}}$, 每个子进程 $B_i$ 的时间片数量为 $N \times \frac{P_i}{P_{\text{total}}}$, 即按优先级比例分配时间片数量.
3. 若进程在其时间片用尽前主动放弃 CPU, 则其未用完的时间片将保留到其下一次调度.

# RPC接口与fast path机制

由于系统是微内核, 系统调用的实现主要依赖于RPC接口(Remote Procedure Call). RPC接口的过程为:

1. 进程通过陷入内核态, 触发系统调用
2. 内核通过RPC机制将系统调用请求发送到对应的服务进程
3. 服务进程处理请求, 并将结果通过RPC机制返回给内核
4. 内核将结果返回给用户进程

进一步的, 我们将其优化为以下机制:

1. 每个RPC提供者同时注册多个待命线程, 每个线程独立处理RPC请求
2. 当内核接收到RPC请求时, 选择一个空闲线程处理该请求
3. 线程处理完请求后, 将结果返回给内核, 并继续等待下一个请求
4. 当没有可用线程时, 内核将请求排队, 待有线程空闲时再处理

进一步的, 一个RPC过程可以是同步的.
对于同步RPC过程, 每次调度调用者线程时,
调用过程会被重定向到被调用者线程上.

进一步的, 我们有所谓fast path机制, 一个支持fast path机制的RPC过程总是同步的:

1. 对于某些RPC功能, 其被注册为支持fast path机制
2. 提供者应当保证, 当线程进入等待状态时, 支持fast path机制的RPC完全不依赖于任何的局部上下文信息(寄存器, 栈等)
3. 当内核接收到fast path RPC请求时, 直接将请求发送到空闲线程, 无需保存和恢复任何上下文信息, 此时的参数直接存储在线程的上下文中(寄存器等)
4. 线程处理完请求后, 直接返回结果给内核, 无需恢复任何上下文信息

# 内存分配器的改进

反正是要改进的

# 驱动接口与能力的设计

我再想想

# ELF加载器的改进

目前的ELF加载器实现较为简单, 仅支持基本的ELF格式和加载方式.

# Loongarch架构支持

目前的内核主要支持RISC-V架构, 需要增加对Loongarch架构的支持.

# EBPF支持

内核应当支持EBPF(Extended Berkeley Packet Filter)功能, 允许用户态程序加载和执行EBPF程序, 以实现高效的网络数据包处理和其他内核级功能扩展.
对于Verifier部分, 我们应当先实现一个基础的EBPF指令集验证器, 确保加载的EBPF程序不会执行非法操作或访问越界内存.

# COW(Copy-On-Write)机制的实现

实现COW机制, 以提高内存使用效率和进程创建性能.

# 在 fork() 函数中检测是否为单线程进程

在 fork() 函数中, 通过检查进程的线程计数器, 来判断当前进程是否为单线程进程.
如果是多线程进程, 则返回错误码, 防止多线程进程调用 fork() 导致的不确定行为.

同时, fork() 时应当保证子进程的能力是父进程相应能力的派生, 例外有且仅有子进程对自己的PCB能力. 此时子进程持有该能力, 而父进程持有该能力的派生.

# 为进程提供对自己能力的遍历接口

提供一个接口函数, 允许进程遍历和查询自己所持有的所有能力.
该接口函数返回一个能力列表, 每个能力包含能力ID, 能力类型, 权限等信息.
该接口函数应当具备适当的权限检查, 仅允许进程查询自己所持有的能力, 防止越权访问其他进程的能力信息.

# 能力的继承与派生机制

实现能力的继承与派生机制, 允许进程在创建子进程时, 将自己的能力以继承或派生的方式传递给子进程.
继承的能力在子进程中保持与父进程相同的权限和属性. 并通过 cap_degrade() 进行降级, 从而在执行新程序时控制权限.

# 共享内存能力的实现

RT

# 实现进程与线程的清理

RT

# 优化等待队列的实现

RT

# 将线程栈由内核分配改为用户态分配

RT