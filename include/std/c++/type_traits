/**
 * @file type_trait
 * @author theflysong (song_of_the_fly@163.com)
 * @brief type_trait
 * @version alpha-1.0.0
 * @date 2026-01-19
 *
 * @copyright Copyright (c) 2026
 *
 */

#pragma once

#include <cstddef>

namespace std {
    // 基础模板：integral_constant（整型常量包装器）
    template <typename T, T v>
    struct integral_constant {
        using value_type = T;
        using type       = integral_constant<T, v>;  // 自身类型

        static constexpr value_type value = v;

        // 转换函数：可以转换为值类型
        constexpr operator value_type() const noexcept {
            return value;
        }

        // 函数调用运算符：可以像函数一样使用
        constexpr value_type operator()() const noexcept {
            return value;
        }
    };

    // 布尔类型特化
    template <bool __v>
    using bool_constant = integral_constant<bool, __v>;
    using true_type     = bool_constant<true>;
    using false_type    = bool_constant<false>;

    // declval
    template <typename T>
    T&& declval() noexcept;

    // Type Relations

    // is_same
    template <typename _Tp, typename _Up>
    struct is_same : public bool_constant<__is_same(_Tp, _Up)> {};
    template <typename _Tp, typename _Up>
    inline constexpr bool is_same_v = is_same<_Tp, _Up>::value;

    // is_base_of
    template <typename _Base, typename _Derived>
    struct is_base_of : public bool_constant<__is_base_of(_Base, _Derived)> {};
    template <typename _Base, typename _Derived>
    inline constexpr bool is_base_of_v = is_base_of<_Base, _Derived>::value;

    // is_convertible
    template <typename _Fp, typename _Tp>
    struct is_convertible : bool_constant<__is_convertible(_Fp, _Tp)> {};
    template <typename _Fp, typename _Tp>
    inline constexpr bool is_convertible_v = is_convertible<_Fp, _Tp>::value;

    // Const - Volatile Modifiers
    template <typename _Tp>
    struct remove_const {
        using type = _Tp;
    };
    template <typename _Tp>
    struct remove_const<const _Tp> {
        using type = _Tp;
    };
    template <typename _Tp>
    struct remove_volatile {
        using type = _Tp;
    };
    template <typename _Tp>
    struct remove_volatile<volatile _Tp> {
        using type = _Tp;
    };
    // remove_cv
    template <typename _Tp>
    struct remove_cv {
        using type = __remove_cv(_Tp);
    };

    // add_const
    template <typename _Tp>
    struct add_const {
        using type = const _Tp;
    };
    // add_volatile
    template <typename _Tp>
    struct add_volatile {
        using type = volatile _Tp;
    };
    // add_cv
    template <typename _Tp>
    struct add_cv {
        using type = volatile const _Tp;
    };

    // 别名
    template <typename _Tp>
    using remove_const_t = typename remove_const<_Tp>::type;
    template <typename _Tp>
    using remove_volatile_t = typename remove_volatile<_Tp>::type;
    template <typename _Tp>
    using remove_cv_t = typename remove_cv<_Tp>::type;
    // Note: a temporary implementation of decay_t, which only removes const and
    // volatile qualifiers
    template <typename _Tp>
    using decay_t = remove_cv_t<_Tp>;
    template <typename _Tp>
    using add_const_t = typename add_const<_Tp>::type;
    template <typename _Tp>
    using add_volatile_t = typename add_volatile<_Tp>::type;
    template <typename _Tp>
    using add_cv_t = typename add_cv<_Tp>::type;

    // Reference Modifiers
    template <typename _Tp>
    struct remove_reference {
        using type = _Tp;
    };
    template <typename _Tp>
    struct remove_reference<_Tp&> {
        using type = _Tp;
    };
    template <typename _Tp>
    struct remove_reference<_Tp&&> {
        using type = _Tp;
    };

    template <typename _Tp>
    struct add_lvalue_reference {
        using type = _Tp&;
    };
    template <typename _Tp>
    struct add_lvalue_reference<_Tp&> {
        using type = _Tp&;
    };
    template <typename _Tp>
    struct add_lvalue_reference<_Tp&&> {
        using type = _Tp&;
    };

    template <typename _Tp>
    struct add_rvalue_reference {
        using type = _Tp&&;
    };
    template <typename _Tp>
    struct add_rvalue_reference<_Tp&> {
        using type = _Tp&&;
    };
    template <typename _Tp>
    struct add_rvalue_reference<_Tp&&> {
        using type = _Tp&&;
    };

    // 别名
    template <typename _Tp>
    using remove_reference_t = typename remove_reference<_Tp>::type;
    template <typename _Tp>
    using add_lvalue_reference_t = typename add_lvalue_reference<_Tp>::type;
    template <typename _Tp>
    using add_rvalue_reference_t = typename add_rvalue_reference<_Tp>::type;

    // Type Traits

    // is_enum
    template <typename _Tp>
    struct is_enum : public bool_constant<__is_enum(_Tp)> {};

    // is_scoped_enum
    template <typename _Tp>
    struct is_scoped_enum : public bool_constant<__is_scoped_enum(_Tp)> {};

    // is_union
    template <typename _Tp>
    struct is_union : public bool_constant<__is_union(_Tp)> {};

    // is_class
    template <typename _Tp>
    struct is_class : public bool_constant<__is_class(_Tp)> {};

    // is_array
    template <typename _Tp>
    struct is_array : public bool_constant<__is_array(_Tp)> {};

    // is_pointer
    template <typename _Tp>
    struct is_pointer : public bool_constant<__is_pointer(_Tp)> {};

    // is_member_pointer
    template <typename _Tp>
    struct is_member_pointer : public bool_constant<__is_member_pointer(_Tp)> {
    };

    // is_member_function_pointer
    template <typename _Tp>
    struct is_member_function_pointer
        : public bool_constant<__is_member_function_pointer(_Tp)> {};

    // is_member_object_pointer
    template <typename _Tp>
    struct is_member_object_pointer
        : public bool_constant<__is_member_object_pointer(_Tp)> {};

    // is_function
    template <typename _Tp>
    struct is_function : public bool_constant<__is_function(_Tp)> {};

    // is_object
    template <typename _Tp>
    struct is_object : public bool_constant<__is_object(_Tp)> {};

    // is_void
    template <typename _Tp>
    struct is_void : public false_type {};
    template <>
    struct is_void<void> : public true_type {};
    template <>
    struct is_void<const void> : public true_type {};
    template <>
    struct is_void<volatile void> : public true_type {};
    template <>
    struct is_void<const volatile void> : public true_type {};

    // 别名
    template <typename _Tp>
    inline constexpr bool is_enum_v = is_enum<_Tp>::value;
    template <typename _Tp>
    inline constexpr bool is_scoped_enum_v = is_scoped_enum<_Tp>::value;
    template <typename _Tp>
    inline constexpr bool is_union_v = is_union<_Tp>::value;
    template <typename _Tp>
    inline constexpr bool is_class_v = is_class<_Tp>::value;
    template <typename _Tp>
    inline constexpr bool is_array_v = is_array<_Tp>::value;
    template <typename _Tp>
    inline constexpr bool is_pointer_v = is_pointer<_Tp>::value;
    template <typename _Tp>
    inline constexpr bool is_function_v = is_function<_Tp>::value;
    template <typename _Tp>
    inline constexpr bool is_void_v = is_void<_Tp>::value;
    template <typename _Tp>
    inline constexpr bool is_member_pointer_v = is_member_pointer<_Tp>::value;
    template <typename _Tp>
    inline constexpr bool is_object_v = is_object<_Tp>::value;

    // extent

    // 默认情况: 非数组类型，大小为0
    template <typename, unsigned _Uint = 0>
    struct extent : public integral_constant<size_t, 0> {};

    // 如果是数组类型, 且已递归到最外层, 则返回数组大小
    template <typename _Tp, unsigned _Size>
    struct extent<_Tp[_Size], 0> : public integral_constant<size_t, _Size> {};

    // 如果还未递归到最外层, 继续递归
    template <typename _Tp, unsigned _Uint, unsigned _Size>
    struct extent<_Tp[_Size], _Uint> : public extent<_Tp, _Uint - 1>::type {};

    // 特化: 不定长数组
    template <typename _Tp>
    struct extent<_Tp[], 0> : public integral_constant<size_t, 0> {};
    template <typename _Tp, unsigned _Uint>
    struct extent<_Tp[], _Uint> : public extent<_Tp, _Uint - 1>::type {};

    // 别名
    template <typename _Tp, unsigned _Uint = 0>
    inline constexpr size_t extent_v = extent<_Tp, _Uint>::value;

    // rank
    template <typename _Tp>
    struct rank : public integral_constant<size_t, __array_rank(_Tp)> {};

    // 别名
    template <typename _Tp>
    inline constexpr size_t rank_v = rank<_Tp>::value;

    // void_t
    template <typename...>
    using void_t = void;

    // enable_if
    template <bool _Bp, typename _Tp = void>
    struct enable_if {};

    template <typename _Tp>
    struct enable_if<true, _Tp> {
        using type = _Tp;
    };

    template <bool _Bp, typename _Tp = void>
    using enable_if_t = typename enable_if<_Bp, _Tp>::type;

    template <typename T>
    typename remove_reference<T>::type&& __move(T&& t) {
        return static_cast<typename remove_reference<T>::type&&>(t);
    }

    template <typename T>
    T&& __forward(typename remove_reference<T>::type& t) {
        return static_cast<T&&>(t);
    }

    template <typename T>
    T&& __forward(typename remove_reference<T>::type&& t) {
        return static_cast<T&&>(t);
    }

    namespace detail {
        // invoke
        template <typename F, typename... Args>
        auto invoke_impl(F&& f, Args&&... args)
            -> decltype(__forward<F>(f)(__forward<Args>(args)...));

        // invoke member function pointer
        template <typename R, typename C, typename... FArgs, typename T,
                  typename... Args>
        auto invoke_impl(R (C::*f)(FArgs...), T&& t, Args&&... args)
            -> decltype((__forward<T>(t).*f)(__forward<Args>(args)...));

        // invoke const member function pointer
        template <typename R, typename C, typename... FArgs, typename T,
                  typename... Args>
        auto invoke_impl(R (C::*f)(FArgs...) const, T&& t, Args&&... args)
            -> decltype((__forward<T>(t).*f)(__forward<Args>(args)...));

        // invoke member object pointer
        template <typename R, typename C, typename T>
        auto invoke_impl(R(C::*f), T&& t) -> decltype(__forward<T>(t).*f);
    }  // namespace detail

    // invoke_result
    template <typename _Fp, typename... _Args>
    struct invoke_result {
        using type =
            decltype(detail::invoke_impl(declval<_Fp>(), declval<_Args>()...));
    };

    template <typename _Fp, typename... _Args>
    using invoke_result_t = typename invoke_result<_Fp, _Args...>::type;
}  // namespace std