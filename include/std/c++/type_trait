/**
 * @file type_trait
 * @author theflysong (song_of_the_fly@163.com)
 * @brief type_trait
 * @version alpha-1.0.0
 * @date 2026-01-19
 *
 * @copyright Copyright (c) 2026
 *
 */

#pragma once

namespace std {
    // 基础模板：integral_constant（整型常量包装器）
    template <typename T, T v>
    struct integral_constant {
        using value_type = T;
        using type       = integral_constant<T, v>;  // 自身类型

        static constexpr value_type value = v;

        // 转换函数：可以转换为值类型
        constexpr operator value_type() const noexcept {
            return value;
        }

        // 函数调用运算符：可以像函数一样使用
        constexpr value_type operator()() const noexcept {
            return value;
        }
    };

    // 布尔类型特化
    using true_type  = integral_constant<bool, true>;
    using false_type = integral_constant<bool, false>;

    // declval
    template<typename T>
    T&& declval() noexcept;

    // is_same
    // 默认: _Tp 和 _Up 不同
    template <typename _Tp, typename _Up>
    struct is_same : public false_type {};

    // 模板特化: _Tp 和 _Up 相同
    template <typename _Tp>
    struct is_same<_Tp, _Tp> : public true_type {};

    // 变量模板别名
    template <typename _Tp, typename _Up>
    inline constexpr bool is_same_v = is_same<_Tp, _Up>::value;

    namespace detail {
        // 检查_Fp是否可以隐式转换为_Tp
        template <typename _Fp, typename _Tp>
        struct is_convertible_impl {
        private:
            // 测试函数
            static void test_func(_Tp);

            // 测试成功的版本
            template <typename F, typename T,
                      typename = decltype(test_func(std::declval<F>()))>
            static std::true_type test(int);

            // 测试失败的版本
            template <typename, typename>
            static std::false_type test(...);

        public:
            using type                  = decltype(test<_Fp, _Tp>(0));
            static constexpr bool value = type::value;
        };

        // 处理void类型的特化
        template <typename _Fp>
        struct is_convertible_impl<_Fp, void> : std::false_type {};

        template <>
        struct is_convertible_impl<void, void> : std::true_type {};

    }  // namespace detail

    // 主模板
    template <typename _Fp, typename _Tp>
    struct is_convertible : detail::is_convertible_impl<_Fp, _Tp>::type {};

    // 变量模板别名
    template <typename _Fp, typename _Tp>
    inline constexpr bool is_convertible_v = is_convertible<_Fp, _Tp>::value;
}  // namespace std