/**
 * @file string
 * @author theflysong (song_of_the_fly@163.com)
 * @brief string
 * @version alpha-1.0.0
 * @date 2026-03-01
 *
 * @copyright Copyright (c) 2026
 *
 */

#pragma once

#include <cstddef>
#include <cstdint>
#include <cuchar>
#include <cwchar>
#include <ios>

namespace std {
    template <class CharT>
    class char_traits;

    template <class CharT>
    class __impl_char_info;

    template <>
    class __impl_char_info<char> {
    public:
        using char_type  = char;
        using int_type   = int;
        using off_type   = std::streamoff;
        using pos_type   = std::streampos;
        using state_type = std::mbstate_t;
    };

    template <>
    class __impl_char_info<wchar_t> {
    public:
        using char_type  = wchar_t;
        using int_type   = std::wint_t;
        using off_type   = std::streamoff;
        using pos_type   = std::wstreampos;
        using state_type = std::mbstate_t;
    };

    template <>
    class __impl_char_info<char8_t> {
    public:
        using char_type  = char8_t;
        using int_type   = unsigned int;
        using off_type   = std::streamoff;
        using pos_type   = std::u8streampos;
        using state_type = std::mbstate_t;
    };

    template <>
    class __impl_char_info<char16_t> {
    public:
        using char_type  = char16_t;
        using int_type   = std::uint_least16_t;
        using off_type   = std::streamoff;
        using pos_type   = std::u16streampos;
        using state_type = std::mbstate_t;
    };

    template <>
    class __impl_char_info<char32_t> {
    public:
        using char_type  = char32_t;
        using int_type   = std::uint_least32_t;
        using off_type   = std::streamoff;
        using pos_type   = std::u32streampos;
        using state_type = std::mbstate_t;
    };

    template <class CharT>
    class __impl_char_traits {
    public:
        using char_type  = __impl_char_info<CharT>::char_type;
        using int_type   = __impl_char_info<CharT>::int_type;
        using off_type   = __impl_char_info<CharT>::off_type;
        using pos_type   = __impl_char_info<CharT>::pos_type;
        using state_type = __impl_char_info<CharT>::state_type;

        static bool eq(const char_type &c1, const char_type &c2) {
            return c1 == c2;
        }

        static bool lt(const char_type &c1, const char_type &c2) {
            return c1 < c2;
        }

        static int compare(const char_type *s1, const char_type *s2, size_t n) {
            for (size_t i = 0; i < n; ++i) {
                if (s1[i] != s2[i]) {
                    return (s1[i] < s2[i]) ? -1 : 1;
                }
            }
            return 0;
        }

        static size_t length(const char_type *s) {
            size_t len = 0;
            while (s[len] != '\0') {
                ++len;
            }
            return len;
        }

        static const char_type *find(const char_type *s, size_t n,
                                     const char_type &c) {
            for (size_t i = 0; i < n; ++i) {
                if (s[i] == c) {
                    return s + i;
                }
            }
            return nullptr;
        }

        static char_type *move(char_type *dest, const char_type *src,
                               size_t n) {
            memmove(dest, src, n * sizeof(char_type));
            return dest;
        }

        static char_type *copy(char_type *dest, const char_type *src,
                               size_t n) {
            memcpy(dest, src, n * sizeof(char_type));
            return dest;
        }

        static void assign(char_type &c1, const char_type &c2) {
            c1 = c2;
        }

        static char_type *assign(char_type *s, size_t n, char_type c) {
            for (size_t i = 0; i < n; ++i) {
                s[i] = c;
            }
            return s;
        }

        static int_type not_eof(int_type c) {
            return (c == eof()) ? 0 : c;
        }

        static char_type to_char_type(int_type c) {
            return static_cast<char_type>(c);
        }

        static int_type to_int_type(char_type c) {
            return static_cast<int_type>(c);
        }

        static bool eq_int_type(int_type c1, int_type c2) {
            return c1 == c2;
        }

        static int_type eof() {
            return static_cast<int_type>(-1);
        }
    };

    template <>
    class char_traits<char> : public __impl_char_traits<char> {};
    template <>
    class char_traits<wchar_t> : public __impl_char_traits<wchar_t> {};
    template <>
    class char_traits<char8_t> : public __impl_char_traits<char8_t> {};
    template <>
    class char_traits<char16_t> : public __impl_char_traits<char16_t> {};
    template <>
    class char_traits<char32_t> : public __impl_char_traits<char32_t> {};
}  // namespace std