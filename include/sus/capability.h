/**
 * @file capability.h
 * @author theflysong (song_of_the_fly@163.com)
 * @brief Capability系统
 * @version alpha-1.0.0
 * @date 2025-12-06
 * 
 * @copyright Copyright (c) 2025
 * 
 */

#pragma once

#include <sus/bits.h>

/**
 * 能力系统简介
 *
 * 能力(Capability)是一种用于访问系统资源的权限标识符。只有持有相应能力的进程才能访问对应的资源。
 * 能力系统通过能力的创建、派生和失效来管理进程对资源的访问权限。
 *
 * 能力类型包括但不限于:
 * 对PCB(进程控制块)、TCB(线程控制块)、设备、文件、共享内存等资源的访问权限。
 *
 * 能力可以由内核或能力提供者进程创建，并可以派生给其他进程。
 * 一般的能力提供者进程只能创建CUSTOM类型的能力，而特殊的能力提供者进程可以创建其他类型的能力(需要经过认证)。
 * 所有的进程要为其它进程创建能力, 必须持有能力提供者能力(PRO)。
 *
 * 例如: VFS进程可以创建文件能力。
 *
 * 其余进程虽然不能创建PCB/TCB/设备等能力, 但可以通过持有的能力访问这些资源。
 * 同时, 进程可以通过派生能力将自己的能力授权给其他进程使用。
 *
 * 能力失效后, 该能力及其派生出的子能力将无法再被使用。
 *
 * 能力主要在获取系统资源时使用, 例如打开文件、访问设备等操作都需要相应的能力。
 * 一般而言, 通过能力获取资源, 伴随的是用户页表中对该资源的映射。
 *
 * 例如, 通过DEV能力访问设备, 会在用户页表中映射该设备的寄存器地址空间。
 * 而通过FLE能力访问文件, 则会在用户页表中映射该文件的数据缓冲区。
 * 更加详细的过程是(以FLE能力为例):
 * 1. 进程调用fopen()等接口打开文件
 * 2. 进程持有指向某个文件的FLE能力。
 * 3. 进程通过该能力向VFS进程请求文件资源
 * 4. VFS进程接收到请求, 开始处理任务
 * 5. VFS进程向内核求证请求进程的FLE能力是否合法
 * 6. VFS进程向内核请求FLE能力指向的文件数据指针
 * 7. VFS进程创建共享内存区域用于文件数据缓冲, 这个过程中VFS获得一个MEM能力
 * 8. VFS进程将该MEM能力派生给请求的进程
 * 9. VFS将该能力返回给请求进程
 * 10. 请求进程接收到MEM能力后, 向内核请求共享内存资源
 * 11. 内核在用户页表中映射该共享内存区域, 并将指针返回给请求进程
 * 12. 请求进程通过映射的指针访问文件数据
 * 13. 请求进程完成对文件的操作后, 通过fclose()等接口关闭文件
 * 14. VFS进程收到关闭请求后, 使该MEM能力失效, 并释放共享内存区域
 *
 * FLE能力不一定只指向一个文件, 它也可以指向一个目录, 以及一族文件/目录等。
 * 一般来说是这几种情况:
 * 1. 指向某个文件的FLE能力
 * 2. 指向某个目录的FLE能力
 * 3. 指向某个目录树的FLE能力
 *
 * 持有一定FLE能力的进程, 可以通过该能力访问对应的文件/目录/目录树。
 * 同时, 其可以向其他进程派生FLE能力, 使其也能访问对应的文件/目录/目录树。
 * 例如, 一个进程持有指向某个目录树的FLE能力,
 * 它可以通过该能力请求一个访问该目录树下某个文件的能力。
 * 它也可以通过向其他进程派生指向该目录树的FLE能力,
 * 使其也能访问该目录下的所有文件。
 *
 * -------------------------------
 *
 * 进一步的, 我们要区分PCB/TCB能力与进程能力/线程能力的区别。
 * PCB能力决定了一个进程是否能够控制某个进程控制块。这决定了它是否能够操作该进程(如调度、终止等)。
 * 而进程能力决定了一个进程是否能够"看见"另一个进程,
 * 以及与之通信(如发送消息、共享内存等)。 如果一个进程不能够"看见"另一个进程,
 * 它就无法与之通信, 也无法向其派生能力。 于是, 一个进程所持有的进程能力的集合,
 * 就是它所知道的进程的集合。 也可以理解为, 在这个进程看来,
 * 只有它所持有进程能力的那些进程是真实存在的。
 * 这样一种进程能力被包装为了"pid"的形式, 从而与其它系统兼容
 *
 * 但是实际上这个"pid"并不是真实的进程ID, 而是一个伪装成pid的进程能力。
 * 对于不同的进程A与B而言, 针对同一个进程C, 它们所得到的"pid"可能是不同的。
 *
 * -------------------------------
 *
 * 由于Capability的控制是完全由内核负责的, 因此用户进程无法伪造能力。
 * 任何试图伪造能力的行为, 都会被内核在使用该能力时检测出来, 并拒绝该操作。
 * 因此, 进程能够使用资源, 当且仅当进程被授权使用资源。
 * 这保证了系统资源访问的安全性与可靠性。
 *
 */

/**
 * @brief Capability指针
 * 
 */
typedef union {
    qword val;
    struct {
        dword cspace;
        dword cindex;
    };
} CapPtr;

#define INVALID_CAP_PTR (CapPtr){.val = 0}

typedef enum {
    CAP_TYPE_NUL    = 0,   // 空能力
    CAP_TYPE_PRC    = 1,   // 进程能力
    CAP_TYPE_PCB    = 2,   // 进程控制块能力
    CAP_TYPE_THR    = 3,   // 线程能力
    CAP_TYPE_TCB    = 4,   // 线程控制块能力
    CAP_TYPE_DEV    = 5,   // 设备能力
    CAP_TYPE_FLE    = 6,   // 文件能力
    CAP_TYPE_INT    = 7,   // 中断能力
    CAP_TYPE_MEM    = 8,   // 内存能力
    CAP_TYPE_PRO    = 9,   // 能力提供者能力
    CAP_TYPE_CUSTOM = 10,  // 自定义能力
    CAP_TYPE_NOT    = 11      // 通知能力
} CapType;

#define NOTIFICATION_BITMAP_SIZE (256)
#define NOTIFICATION_BITMAP_QWORDS (NOTIFICATION_BITMAP_SIZE / (8 * sizeof(qword)))